{"name":"ProcScript","tagline":"A JavaScript framework that makes it easier to do large-scale application development.","body":"ProcScript\r\n================================\r\n\r\nA JavaScript framework that makes it easier to do large-scale application development.\r\n\r\n\r\nWhy ProcScript?\r\n---------------------\r\n\r\nWhile developing HTML5 web applications, I came to love and hate JavaScript.  \r\n\r\nI love JavaScript because it is very dynamic and flexible and I really love the \r\nunparalleled *write-once, run-anywhere* reach of HTML5 apps.  \r\n\r\nI hate JavaScript because it is *too* dynamic and flexible.  I encountered many frustrating\r\nruntime errors that would be prevented by a type-checking system.  Many of the toughest \r\nbugs to find and fix resulted from callers passing incomplete or mis-matched parameter lists to \r\nfunctions.  \r\n\r\nI also found that while JavaScript is great for asynchronous programming, doing heavily \r\nsynchronous programming in JavaScript is almost impossible (see *The Pyramid of Doom*).\r\n\r\nhttp://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/\r\n\r\nIf the number of sequenced operations is longer than four or five, the nested JavaScript \r\ncallback approach becomes very hard to manage.\r\n\r\nTo overcome these JavaScript problems, I developed ProcScript.  ProcScript adds type checking and synchronous programming support to JavaScript.\r\n\r\n\r\nProcScript features\r\n-------------------------\r\n\r\n* Pure JavaScript: No Compilers or Preprocessors\r\n* Type Checks Input and Output Parameters\r\n* Makes Synchronous Programming Easy\r\n* Use C# or Java skills to write JavaScript\r\n* Great Debugging Support\r\n* Provides Code Coverage Statistics\r\n* Works with Promises\r\n* Perform Sequence, Parallel, Fallback and Race operations with timeout and abort.\r\n\r\n\t\r\nProcScript Demos\r\n------------------------------\r\n\r\nBefore we dive in, let me mention the ProcScript demos.  These simple demos are brief and heavily commented and provide a great way to quickly learn ProcScript.\r\n\r\ncorsDemo\r\n------------------------------\r\nThis demo sends Cross Origin Resource Sharing (CORS) requests to websites and shows how to use ProcScript \r\nto make XmlHttpRequests and write to a WebSQL database. \r\n\r\nprocRunnerDemo\r\n------------------------------\r\nThis demo shows how to run multiple Procs in Sequence, Parallel, Fallback or Race operations with Proc Runners.  The \r\nattractive, interactive GUI gives you full control over duration, timeout and abort and allows arbitrary nesting of Proc Runners.\r\n\r\n\r\n\r\nProcs\r\n-------\r\n\r\nThe ProcScript framework allows you to define and run Procs.  A Proc is like an enhanced \r\nJavaScript function with type-checked input and output parameters and synchronous programming support.  A Proc has the following properties:\r\n\r\n* Name:  The unique name of the Proc.\r\n* Signature:  An object literal that defines the Proc's input and output parameters.\r\n* Blocks:  The code of the Proc specified as an array of JavaScript functions.  ProcScript executes these functions synchronously, in array order.\r\n  \r\n  \r\nMy first Proc\r\n--------------\r\n\r\nWhen you include *ps.js* in your web app, you gain access to the ProcScript global\r\nvariable (`PS`).  `PS.defineProc()` takes an object literal called a *proc config* as input.  The Proc config must have these properties:\r\n\r\n`name` gives the unique name of the Proc.\r\n\r\n`fnGetSignature` returns an object identifying the Proc's input and output parameters.  \r\n\r\n`blocks` defines the code of the Proc as an array of functions.\r\n\r\nFor example, the following example defines a simple Proc called \"MyFirstProc\":\r\n\r\n    var MyFirstProc = PS.defineProc({\r\n\r\n        name: \"MyFirstProc\",\r\n        fnGetSignature: function () {\r\n            return {\r\n                input1: [\"string\"],\r\n                output1: [Array, \"out\"]\r\n            };\r\n        },\r\n        blocks: [\r\n        function blockFunction1() {\r\n            console.log(this.input1);\r\n            return PS.NEXT;\r\n        },\r\n        function blockFunction2() {\r\n            this.output1 = [ \"Hello World!\" ];\r\n            return PS.NEXT;\r\n        }]\r\n\t\t\r\n    });\r\n\r\nThe proc config specifies that *MyFirstProc* takes one *string* input (`input1`) and produces one *Array* output (`output1`).  It has two blocks of code: \r\nthe first block writes the value of `input1` to the console and the second sets the value of `output1` to an array containing \"Hello World!\".\r\n\r\n`PS.defineProc()` registers *MyFirstProc* with the ProcScript framework and returns the MyFirstProc constructor function.  Use the constructor  \r\nto create and run instances of *MyFirstProc* like this:\r\n\r\n\tvar procInstance = new MyFirstProc({input1: \"Hi Mom!\"});\r\n\tprocInstance.run();\r\n\r\n\r\nThe signature\r\n-----------------\r\n\r\nThe `fnGetSignature` member of the proc config is a function that returns an object literal called a *signature object*.\r\nThe *signature object* defines the input and output parameters of the Proc and has this structure:\r\n\r\n\t{\r\n\tparamName1: [ paramType, paramDir ],\r\n\tparamName2: [ paramType, paramDir ],\r\n\t...\r\n\tparamNameN: [ paramType, paramDir ]\r\n\t}\r\n\t\r\n`paramType`\r\n\r\nThe following `paramType` values are allowed:\r\n\r\n*\t\"boolean\", \"number\", \"string\" or \"function\"   \t\r\n\tThe parameter value must be a JavaScript boolean, number, string or function value.\r\n\t\r\n*\t*class constructor function*\t\t\t\t\r\n\tThe parameter value must be an `instanceof` the class.\r\n\t\r\n*\tnull        \t\r\n\tThe parameter value may be any type.\r\n\r\n\t\r\n`paramDir`\r\n\r\n\r\nThe following `paramDir` values are allowed:\r\n\r\n*\t\"in\"       \r\n\tThe parameter is input-only.\r\n\t\r\n*\t\"in-out\"   \r\n\tThe parameter is received as input and returned as output.\r\n\t\r\n*\t\"out\"      \r\n\tThe parameter is output-only.\r\n\t\r\n*\tundefined  \r\n\tIf no `paramDir` is specified, it defaults to \"in\".\r\n\r\n\r\n\r\nEnforcing the signature\r\n------------------------------------\r\nNotice that the `MyFirstProc` constructor takes an object literal input called a *parameter object*:\r\n\r\n\tvar procInstance = new MyFirstProc({input1: \"Hi Mom!\"});\r\n\r\nWhen you create a Proc instance, ProcScript checks the parameter object against the signature object.  If the parameter object does not contain \r\na value of the right type for each \"in\" and \"in-out\" parameter, ProcScript throws an error.  \r\n\r\nLikewise, ProcScript checks the parameter object against the signature just before a Proc returns to its caller. If the parameter object \r\ndoes not contain a value of the right type for each \"in-out\" and \"out\" parameter, ProcScript throws an error.\r\n\r\n\r\nType checking objects\r\n--------------------------------------\r\n\r\nAs mentioned above, if the `paramType` of a parameter is a class constructor function, ProcScript checks that the parameter value is an `instanceof` that class.  \r\n\r\nThis works for core JavaScript classes (like Date or Array) but also for user-defined classes.  For example, if you define a Point class like this:\r\n\r\n\tfunction Point(x, y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\r\n\tPoint.prototype.toString = function () {\r\n\t\treturn \"{\" + this.x + \",\" + this.y + \"}\";\r\n\t}\r\n\r\nYou can write a Proc that inputs or outputs a `Point` object like this:\r\n\r\n\tvar PointProc = PS.defineProc({\r\n\r\n\t\tname: \"PointProc\",\r\n\t\tfnGetSignature: function () {\r\n\t\t\treturn {\r\n\t\t\t\tinPoint: [Point]\r\n\t\t\t};\r\n\t\t},\r\n\t\tblocks: [\r\n\t\tfunction () {\r\n\t\t\tconsole.log(this.inPoint.toString());\r\n\t\t\treturn PS.NEXT;\r\n\t\t}]\r\n\t\t\r\n\t});\r\n\r\n\r\n\t\r\nBlock functions and Proc Locals\r\n----------------------------------\r\n\r\nEach block function in a Proc is a normal JavaScript function.  You should give each block function a\r\ndescriptive name as this makes Proc stack traces more informative and readable.  If you don't give a block function a \r\nname, ProcScript auto-names it `block_N` where `N` is the index of the function in the `blocks` array.\r\n\r\n\r\n\r\nProc locals\r\n----------------\r\n\r\nInside a block function, `this` refers to the Proc instance that is running.  Properties of the Proc instance \r\nare referred to as *Proc locals*.\r\n\r\nFor example, this block function sets Proc local `x` to 'hello'.\r\n\r\n\tfunction blockFunc () {\r\n\t\tthis.x = 'hello';\r\n\t}\r\n\t\r\nA Proc local is available in the block function where it is declared and in subsequent block functions.  \r\n\r\nProcScript automatically creates Proc locals for each \"in\" and \"in-out\" parameter.  `blockFunction1` of `MyFirstProc` \r\nshows this with the \"in\" parameter `input1`:\r\n\r\n        function blockFunction1() {\r\n            console.log(this.input1);\r\n            return PS.NEXT;\r\n        }\r\n\r\nTo set an \"in-out\" or \"out\" parameter, just set a Proc local with the parameter's name to the desired value.  `blockFunction2` of `MyFirstProc` \r\nshows this with \"out\" parameter `output1`:\r\n\r\n        function blockFunction2() {\r\n            this.output1 = [ \"Hello World!\" ];\r\n            return PS.NEXT;\r\n        }\r\n\r\n\r\nBlock function return values\r\n-----------------------------------\r\n\r\nAll block functions must return one of the following values.  The return value tells ProcScript what to do next:\r\n\r\n*\t`PS.NEXT`       \r\n\tRun the next block function.\r\n\t\r\n*\t`PS.RETURN`   \r\n\tReturn to the caller of this Proc.\r\n\t\r\n*\t`PS.BREAK`       \r\n\tBreak out of a loop Proc.\r\n\t\r\n*\t`PS.CONTINUE`   \r\n\tSkip to the next iteration of a loop Proc.\r\n\t\r\n*\t*Proc Instance*      \r\n\tRun *Proc Instance* and pass its parameter object to the next block function.\r\n\t\r\n*\t`PS.WAIT_FOR_CALLBACK`  \r\n\tAdapter Procs return this value so ProcScript will wait for a callback from a blocking function.\r\n\r\n\t\r\nIf a block function returns anything other than one of these values, ProcScript throws an error.\r\n\r\n\r\n\r\n\t\r\nChaining Procs\r\n-----------------------------------\r\n\r\nIf a block function returns a Proc instance, ProcScript runs it and passes its parameter object to the next block function.  This \r\nlets you chain Procs together into call stacks.\r\n\r\nHere is a simple example:\r\n\r\n    var ProcCallsProc = PS.defineProc({\r\n\r\n        name: \"ProcCallsProc\",\r\n        fnGetSignature: function () {\r\n            return {};\r\n        },\r\n        blocks: [\r\n        function blockFunction1() {\r\n            return new MyFirstProc({input1: \"Hi Mom!\"});\r\n        },\r\n        function blockFunction2(paramObj) {\r\n\t\t\tconsole.log(paramObj.output1[0]);\r\n            return PS.NEXT;\r\n        }]\r\n\t\t\r\n    });\r\n\r\n\t\t\t\t\r\nIn `ProcCallsProc`, `blockFunction2` receives the parameter object from `MyFirstProc` in variable `paramObj`.\r\n\r\nRunning `ProcCallsProc` like this:\r\n\t\r\n\tnew ProcCallsProc({}).run();\r\n\r\nproduces this console output:\r\n\r\n\tHi Mom!\r\n\tHello World!\r\n\r\n\r\n\r\n\r\nProc call stacks\r\n--------------------\r\n\r\nThe first Proc Instance in a call stack is called the root Proc.  When a root Proc runs, \r\nProcScript allocates a virtual *thread* for that root Proc and its descendant (callee) Procs.\r\n\r\nYou can dump the call stack from any Proc Instance in a thread with this function:\r\n\r\n\tProc.callStackToString()\r\n\t\r\nThe stack dump looks like this:\r\n\r\n\tProc Call Stack:\r\n\t ProcScript Thread Id: 0, Created: Tue Jun 04 2013 14:05:05 GMT-0500 (Central Daylight Time)\t \r\n\t MyFirstProc.blockFunction1\r\n\t ProcCallsProc.blockFunction1\r\n\r\nEach Proc Instance in the call chain is listed, one per line, with the root Proc at the bottom.\r\n\r\nNote that the Proc call stack starts with:\r\n\r\n\tProcScript Thread Id: 0 Created ...\r\n\t\r\nOnce again, this is not an operating system thread but a *virtual* ProcScript thread.  \r\n\r\nThe Proc call stack contains the chain of Proc Instances that called each other leading up to the breakpoint or exception.  Each entry \r\nin the Proc call stack is of the form:\r\n\r\n\tProc Name.Block Function Name\r\n\r\nIn the example above, block function `blockFunction1` in Proc `ProcCallsProc` called Proc `MyFirstProc`.  The breakpoint or exception occured in \r\n`blockFunction1` of `MyFirstProc`.\r\n\r\n\r\nTo dump the call stacks of all active ProcScript threads, use this function:\r\n\r\n\tPS.threadsToString()\r\n\r\n\t\r\n_catch and _finally block functions\r\n-------------------------------------\r\n\r\nIf you name a block function *_catch* or *_finally*, ProcScript treats it as the catch or finally clause for the Proc.  There can only be  \r\none _catch or _finally block function in a Proc and they must come last in the `blocks` array.\r\n\r\nThe _catch and _finally block functions perform the same duties for Procs that `catch` and `finally` clauses do for JavaScript\r\nfunctions.  If a block function throws an error, ProcScript passes it to the Proc's _catch block function for handling.  If the Proc has no \r\n_catch block function, ProcScript propagates the error to the caller Proc until it finds one with a _catch handler.  \r\n\r\nIf a Proc has a _finally block function, ProcScript *always* runs it before returning to the Proc's caller, regardless\r\nof whether the Proc failed or succeeded.\r\n\r\nHere is a Proc with _catch and _finally block functions:\r\n\r\n    var CatchFinallyProc = PS.defineProc({\r\n\r\n        name: \"CatchFinallyProc\",\r\n        fnGetSignature: function () {\r\n            return {\r\n            };\r\n        },\r\n        blocks: [\r\n        function doIt() {\r\n\t\t\tconsole.log(\"doIt: start spinner....\");\t\t\t\r\n\t\t\tundefinedFunction();\r\n            return PS.NEXT;\r\n        },\r\n\t\tfunction _catch (err) {\r\n            console.log(\"_catch: err=\" + err);\r\n\t\t\treturn PS.NEXT;\r\n\t\t},\r\n\t\tfunction _finally () {\r\n\t\t\tconsole.log(\"_finally: stop spinner....\");\r\n\t\t\treturn PS.NEXT;\r\n\t\t}]\r\n\t\t\r\n    });\r\n\r\nNote that block function `doIt` calls `undefinedFunction()` which causes a JavaScript error.  If you run `CatchFinallyProc` like so:\r\n\t\r\n\tnew CatchFinallyProc({}).run();\r\n\r\nYou will see this output:\r\n\r\n\tdoIt: start spinner....\r\n\t\r\n\t...ProcScript Stack Trace...\r\n\t\r\n\t_catch: err=ReferenceError: undefinedFunction is not defined\r\n\t_finally: stop spinner....\r\n\r\n\t\r\n\r\nLoop Procs\r\n----------------------\r\n\r\nProcScript supports four loop constructs:\r\n\r\n1. For\r\n2. ForEach \r\n3. While\r\n4. Do...While\r\n\r\nProcScript implements these constructs with *Loop Procs*.  You define a loop Proc by specifying a loop property in its proc config. \r\n\r\n\r\nFor loops\r\n--------------------\r\n\r\nDefine a `For` loop proc with the `fnForLoop` property like so:\r\n\r\n\tvar ForLoopProc = PS.defineProc({\r\n\r\n\t\tname: \"ForLoopProc\",\r\n\t\tfnGetSignature: function () {\r\n\t\t\treturn {\r\n\t\t\t\tarr: [Array]\r\n\t\t\t};\r\n\t\t},\r\n\t\tfnForLoop: function () {\r\n\t\t\treturn {\r\n\t\t\t\tinit: \t\t\t\tfunction () { this.i = this.arr.length-1; },\r\n\t\t\t\tbeforeIteration: \tfunction () { return this.i >= 0; },\r\n\t\t\t\tafterIteration: \tfunction () { this.i -= 2; },\t\t\t\r\n\t\t\t};\r\n\t\t},\r\n\t\tblocks: [\r\n\t\tfunction blockFunction1() {\r\n\t\t\tconsole.log(this.arr[this.i]);\r\n\t\t\treturn PS.NEXT;\r\n\t\t}]\r\n\t\t\r\n\t});\r\n\r\nProcScript runs the For loop Proc as follows:\r\n\r\n\t1. Run the `init` function.\r\n\t2. Run `beforeIteration` \r\n\t\t- If it returns true, run the entire Proc, then `afterIteration` and then go to step 2 again.\r\n\t\t- If it returns false, return to the Proc's caller.\r\n\r\nThis is equivalent to the following `for` loop in Java:\r\n\r\n\tpublic void forLoop (char[] arr)\r\n\t{\r\n\t\tfor (int i=arr.length-1; i >=0; i -= 2)\r\n\t\t{\r\n\t\t\tSystem.out.println(arr[i]);\r\n\t\t}\r\n\t}\r\n\r\nRun ForLoopProc like this:\t\r\n\r\n\tnew ForLoopProc({arr: ['a','b','c','d','e','f']}).run();\r\n\r\nand you will see this output:\r\n\r\n\tf\r\n\td\r\n\tb\r\n\r\n\r\nForEach loops\r\n----------------------\r\n\r\nDefine a `ForEach` loop proc with the `fnGetForEachArray` property like so:\r\n\r\n    var MyForEachProc = PS.defineProc({\r\n\r\n        name: \"MyForEachProc\",\r\n        fnGetSignature: function () {\r\n            return {\r\n                input1: [\"string\"],\r\n\t\t\t\tarr: [Array]\r\n            };\r\n        },\r\n\t\tfnGetForEachArray: function () { return this.arr; },\r\n        blocks: [\r\n        function blockFunction1() {\r\n            console.log(this.getCurrentForEachItem());\r\n            console.log(this.getCurrentLoopIterationIndex());\r\n            return PS.NEXT;\r\n        }]\r\n\t\t\r\n    });\r\n\r\nThe `fnGetForEachArray` property defines a function that returns an array.  ProcScript calls this function once, at Proc \r\nstartup time, and then executes the Proc once for each member of the resulting array.  \r\n\r\nThis example demonstrates the following loop support functions:\r\n\r\n`Proc.getCurrentForEachItem()`\t\t\treturns the current item in the `ForEach` array.\r\n\r\n`Proc.getCurrentLoopIterationIndex()`\treturns the current iteration count of the loop Proc *(zero-based)*.\r\n\t\r\n`Proc.getCurrentForEachItem()` returns null if called from a Proc that is not a `ForEach` loop proc.  \r\n`Proc.getCurrentLoopIterationIndex()` returns null if called from a non-loop Proc.\r\n\r\n\t\r\n\t\r\nWhile loops\r\n--------------------------\r\n\r\nDefine a `While` loop proc with the `fnWhileTest` property like so:\r\n\r\n    var WhileProc = PS.defineProc({\r\n\r\n        name: \"WhileProc\",\r\n        fnGetSignature: function () {\r\n            return {\r\n                input1: [\"string\"],\r\n\t\t\t\tbContinue: [\"boolean\"]\t\t\t\t\r\n            };\r\n        },\r\n\t\tfnWhileTest: function () { return this.bContinue; },\r\n        blocks: [\r\n        function blockFunction1() {\r\n\t\t\tthis.i = this.getCurrentLoopIterationIndex();\r\n            console.log(this.i);\r\n            return PS.NEXT;\r\n        },\r\n        function blockFunction2() {\r\n            if (this.i == 100) {\r\n\t\t\t\tthis.bContinue = false;\r\n\t\t\t}\r\n            return PS.NEXT;\r\n        }]\r\n\t\t\r\n    });\r\n\r\nThe `fnWhileTest` property defines a function that returns a boolean (true or false) value.  ProcScript calls \r\nthis function before executing the first block function in the Proc.  If it returns false, ProcScript returns to \r\nthe caller.  If it returns true, ProcScript runs the Proc.  \r\n\r\nProcScript repeats this process until the `fnWhileTest` function returns false.\r\n\r\n\r\nDo...While loops\r\n--------------------------\r\n\r\nDefine a `Do...While` loop proc with the `fnDoWhileTest` property like so:\r\n\r\n\tvar DoWhileProc = PS.defineProc({\r\n\r\n\t\tname: \"DoWhileProc\",\r\n\t\tfnGetSignature: function () {\r\n\t\t\treturn {\r\n\t\t\t\tarr: [Array]\r\n\t\t\t};\r\n\t\t},\r\n\t\tfnDoWhileTest: function () {\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tblocks: [\r\n\t\tfunction blockFunction1() {\r\n\t\t\tconsole.log(this.arr[this.getCurrentLoopIterationIndex()]);\r\n\t\t\treturn PS.NEXT;\r\n\t\t}]\r\n\t\t\r\n\t});\r\n\r\n\r\nThe `fnDoWhileTest` property defines a function that returns a boolean (true or false) value.  ProcScript calls \r\nthe `fnDoWhileTest` function after executing the last block function in the Proc.  If it returns false, ProcScript returns to \r\nthe caller.  If it returns true, ProcScript runs the Proc again. \r\n\r\n\r\nControl Flow in loop Procs\r\n------------------------------------------\r\n\r\nIn a loop Proc, return value `PS.CONTINUE` works like the JavaScript `continue` statement.  ProcScript skips the \r\nremaining block functions and begins running the next iteration of the loop.  Likewise, return value `PS.BREAK` works like the \r\nJavaScript `break` statement.  It makes ProcScript immediately return to the Proc's caller.  \r\n\r\nIf you define and run this loop Proc:\r\n\r\n\r\n    var LoopControlsProc = PS.defineProc({\r\n\r\n        name: \"LoopControlsProc\",\r\n        fnGetSignature: function () {\r\n            return {\r\n                input1: [\"string\"],\r\n\t\t\t\tarr: [Array]\r\n            };\r\n        },\r\n\t\tfnGetForEachArray: function () { return this.arr; },\r\n        blocks: [\r\n        function blockFunction1() {\r\n\t\t\tthis.i = this.getCurrentLoopIterationIndex();\r\n\t\t\tif (this.i == 1) {\r\n\t\t\t\treturn PS.CONTINUE;\r\n\t\t\t} else if (this.i == 3) {\r\n\t\t\t\treturn PS.BREAK;\r\n\t\t\t}\r\n            return PS.NEXT;\r\n        },\r\n\t\tfunction blockFunction2 () {\r\n            console.log(this.input1 + \": i=\" + this.i);\r\n\t\t\treturn PS.NEXT;\r\n\t\t}]\r\n\t\t\r\n    });\r\n\t\r\n\tnew LoopControlsProc({input1: \"LoopControlsProc\", arr: [0,1,2,3,4]}).run();\r\n\t\r\nyou will get this console output:\r\n\r\n\tLoopControlsProc: i=0\r\n\tLoopControlsProc: i=2\r\n\r\n\r\n\r\nIf a block function in a non-loop Proc returns `PS.CONTINUE` or `PS.BREAK`, ProcScript throws an error.\r\n\r\nCatch-Finally in loop Procs\r\n------------------------------------------\r\n\r\nIf a loop Proc has _catch or _finally block functions, ProcScript behaves as if they are outside the loop, not inside.  The equivalent \r\nJavaScript code would look like this:\r\n\r\n\ttry {\r\n\t\twhile (bContinue) {\r\n\t\t\t..\r\n\t\t}\r\n\t} catch () {\r\n\t} finally {\r\n\t}\r\n\r\nIf you want the try-catch inside the loop like this:\r\n\r\n\twhile (bContinue) {\r\n\t\ttry {\r\n\t\t\t...\r\n\t\t} catch () {\r\n\t\t} finally {\r\n\t\t}\r\n\t}\r\n\r\nthen put the _catch and _finally in a non-loop Proc and call it from the loop Proc.\r\n\r\n\t\r\n\t \r\nAdapter Procs\r\n---------------------------------------------------\r\n\r\nAn Adapter Proc turns a blocking function into a Proc.  Writing an Adapter Proc is simple:  \r\njust set the `adapter` property in the proc config and make the blocking function call \r\n`PS.procSucceeded` or `PS.procFailed` as appropriate.\r\n\r\nHere is an example from the ProcScript demo app:\r\n\t\r\n    // XHR.makeCorsRequestProc is an Adapter Proc for XmlHttpRequest\r\n\r\n    XHR.makeCorsRequestProc = PS.defineProc({\r\n        name: \"XHR.makeCorsRequestProc\",\r\n        fnGetSignature: function () {\r\n            return {\r\n                method: [\"string\"],\r\n                url: [\"string\"],\r\n                responseText: [\"string\", \"out\"]  \r\n            };\r\n        },\r\n        adapter: true,\r\n        blocks: [\r\n        function sendRequest() {\r\n            var proc = this;\r\n            proc.responseText = null;   // initialize the 'responseText' output parameter\r\n\r\n            var xhr = XHR.createCORSRequest(this.method, this.url);\r\n            if (!xhr) {\r\n                throw new Error('[XHR.makeCorsRequest]  CORS not supported by your browser.')\r\n            }\r\n\r\n            xhr.onload = function () {\r\n                // The Adapter Proc succeeded\r\n                proc.responseText = xhr.responseText;   // set the 'responseText' output parameter \r\n                PS.procSucceeded(proc)        \r\n            };\r\n\r\n            xhr.onerror = function () {\r\n                // The Adapter Proc failed\r\n                PS.procFailed(proc, '[XHR.makeCorsRequest]  CORS request resulted in error.\\n')\r\n            };\r\n\r\n            xhr.send();\r\n\r\n            // Tell ProcScript to wait for a callback from the blocking function above.\r\n            return PS.WAIT_FOR_CALLBACK;\r\n        }]\r\n\t\t\r\n    });\r\n\r\n\t\r\nNote how `XHR.makeCorsRequestProc` stashes a reference to itself in variable `proc` and passes it to \r\nthe `PS.procSucceeded` or `PS.procFailed` function.  \r\n\r\n`PS.procSucceeded` tells ProcScript that the Adapter Proc completed successfully.  Before calling this function, \r\nthe Adapter Proc must set the value of its \"in-out\" or \"out\" parameters.  \r\n\r\n`PS.procFailed` tells ProcScript that the Adapter Proc failed.  The second parameter to `PS.procFailed` \r\nis a string containing the reason for the failure.  ProcScript propagates this error string up the Proc call stack \r\nas described in the *_catch and _finally block functions* section of this readme.\r\n\r\n\r\nUsing Adapter Procs\r\n---------------------------------------------------\r\n\r\nOnce you have defined an Adapter Proc, you can call it as you would any other Proc. Here is an example from the ProcScript demo app:\r\n\r\n\treturn new XHR.makeCorsRequestProc({\r\n\t\tmethod: this.httpMethodValue,\r\n\t\turl: this.txtURLValue\r\n\t});\r\n\r\n\t\r\nAdapter Procs can only have one block function and they cannot have _catch or _finally clauses.  An Adapter Proc's\r\nblock function must return `PS.WAIT_FOR_CALLBACK`, any other return value causes ProcScript to throw an error.  If a \r\nnon-Adapter Proc returns `PS.WAIT_FOR_CALLBACK`, ProcScript throws an error.  \r\n\r\n\t\r\nWorking with Promises\r\n---------------------------------------\r\nProcScript works with Promise frameworks like Q:\r\n\r\nhttps://github.com/kriskowal/q\r\n\r\nand JQuery:\r\n\r\nhttp://api.jquery.com/Types/#Deferred\r\n\r\nhttp://api.jquery.com/Types/#Promise\r\n\r\n`PS.promiseToRun` takes in a deferred, a Proc instance and (optionally) runParams, and returns a promise:\r\n\r\n\tPS.promiseToRun(deferred, proc, runParams)\r\n\r\n`PS.promiseToRun` runs the specified Proc instance with the specified runParams (if any).  If the Proc succeeds, \r\nit resolves the deferred with its parameter object like so:\r\n\r\n\tdeferred.resolve(this.getParameterObject())\r\n\r\nIf it fails, it rejects the deferred with its failure object like so:\r\n\r\n\tdeferred.reject(this.getFailure())\r\n\t\r\nThis lets you run Proc instances as part of a promise chain.  Here is an example using Q:\r\n\r\n\tfnReturnsPromise().then( \r\n\t\t\r\n\tfunction () { \r\n\t\treturn PS.promiseToRun(Q.defer(), new MyProc());\r\n\t}).then(\r\n\r\n\tfunction () {\r\n\t\tfnReturnsPromise() \r\n\t});\r\n\r\nand here is an example using JQuery:\r\n\r\n\tfnReturnsPromise().then( \r\n\t\t\r\n\tfunction () { \r\n\t\treturn PS.promiseToRun($.Deferred(), new MyProc());\r\n\t}).then(\r\n\r\n\tfunction () {\r\n\t\tfnReturnsPromise() \r\n\t});\r\n\r\n\t\r\n\t\r\nProcScript debugging\r\n------------------------------------------\r\n\r\nIncomplete or confusing error messages are frustrating and waste valuable development time.  If an exception occurs or \r\na developer uses the framework incorrectly, ProcScript makes every effort to provide complete and helpful error messages.  \r\n\r\nProcScript maintains a Proc call stack for each Proc call chain.  If an unhandled exception occurs in a block function, \r\nProcScript writes a detailed error summary to the console including the Proc call stack as well as the JavaScript call stack.  \r\n\r\nHere is an example from the ProcScript demonstration app:\r\n\r\n\t[onProcException] localhost/:14\r\n\terr=Error: [App.initDbProc]  simulated exception in 'createTablesIfNecessary' block function localhost/:15\r\n\terrorMessage: localhost/:17\r\n\tUnhandled exception in App.initDbProc.createTablesIfNecessary\r\n\r\n\tJavaScript Error Object:\r\n\t Error.message=[App.initDbProc]  simulated exception in 'createTablesIfNecessary' block function\r\n\t Error.stack=Error: [App.initDbProc]  simulated exception in 'createTablesIfNecessary' block function\r\n\t\tat createTablesIfNecessary (http://localhost/psDemo/app.js:147:19)\r\n\t\tat procDispatch (http://localhost/psDemo/app/utility/ps.js:1074:27)\r\n\t\tat MessagePort.channel.port1.onmessage (http://localhost/psDemo/app/utility/ps.js:86:13)\r\n\r\n\tProc Call Stack:\r\n\t Thread Id: 0, Created: Tue Jun 04 2013 14:05:05 GMT-0500 (Central Daylight Time)\r\n\r\n\t App.initDbProc.createTablesIfNecessary\r\n\t App.corsTestProc.isDbPopulated\r\n\r\nThe JavaScript stack trace is listed under the heading `JavaScript Error Object:`. \r\n\r\nThe debugging tools in many browsers allow you to click on any line in the JavaScript stack trace to go straight \r\nto the associated line in the JavaScript source.\r\n\r\nThe Proc call stack is listed under the heading `Proc Call Stack:`.  \r\n\r\n\r\nThe combination of the JavaScript and ProcScript call stacks is very helpful in debugging web applications.\r\n\r\n\r\nListening for ProcScript events\r\n------------------------------------------\r\n\r\nYou can register or un-register for ProcScript events using these functions:\r\n\r\n\tPS.addListener(eventType, f)\r\n\tPS.removeListener(eventType, f)\r\n\r\nThe following `eventType` values are supported:\r\n\r\n\"procException\"  \r\n\r\nProcScript notifies \"procException\" listeners when an exception occurs in a Proc.  \r\nProcScript passes the following parameters to the registered callback function:\r\n\r\n`err` the thrown error value.\r\n\r\n`errorMessage` the detailed error summary (including stack traces) that ProcScript creates to describe `err`.\r\n\r\nHere is an example of a listener registering for \"procException\" events:\r\n\r\n        var onProcException = function (err, errorMessage) {\r\n\r\n            console.log(\"[onProcException]\");\r\n            console.log(\"err=\" + err);\r\n\r\n            console.log(\"errorMessage:\");\r\n            console.log(errorMessage);\r\n        }\r\n\r\n        // To get a callback from ProcScript when a Proc failure happens,\r\n        // register as a 'procException' listener.\r\n        PS.addListener('procException', onProcException);\r\n\r\nand here is how to un-register that listener:\r\n\r\n        PS.removeListener('procException', onProcException);\r\n\t\r\n\r\nCode coverage statistics\r\n---------------------------\r\n\r\nTo get code coverage statistics from ProcScript, call this function:\r\n\r\n\tPS.cloneProcRegistry()\r\n\r\nThis returns a deep copy of the ProcScript registry.  It is safe for you to use this copy \r\nwithout affecting the actual ProcScript registry.\r\n\r\nThe Registry object returned by `PS.cloneProcRegistry()` has the following structure:\r\n\r\n\t*Proc Registry Object*\r\n\t{\r\n\t\t<procName1>: <ProcRecord>\r\n\t\t<procName2>: <ProcRecord>\r\n\t\t...\r\n\t\t<procNameN>: <ProcRecord>\r\n\t}\r\n\t\r\nwhere:\r\n\r\n`<procNameN>` is the name of the Proc as specified in the call to `PS.defineProc` and\r\n`<ProcRecord>` is an object with the following structure:\r\n\r\n\t*ProcRecord Object*\r\n\t{ \r\n\t\trunCount: <number>,\r\n\t\tblockRecords: <BlockRecords object>\r\n\t}\r\n\t\r\nwhere:\r\n\r\n`runCount` is the number of times ProcScript has run the Proc and\r\n`blockRecords` is an object with the following structure:\r\n\r\n\t*BlockRecords Object*\r\n\t{ \r\n\t\t<blockName1>: <BlockRecord>\r\n\t\t<blockName2>: <BlockRecord>\r\n\t\t...\r\n\t\t<blockNameN>: <BlockRecord>\r\n\t}\r\n\r\nwhere:\r\n\r\n`<blockNameN>` is the name of the block function (user-specified or auto-named) and \r\n`<BlockRecord>` is an object with the following structure:\r\n\t\r\n\t*BlockRecord Object*\r\n\t{ \r\n\t\trunCount: <number>\r\n\t}\r\n\r\nwhere:\r\n\r\n`runCount` is the number of times ProcScript has run the block function.\r\n\r\n\r\nUsing code coverage statistics\r\n--------------------------------\r\n\r\nNote that the runCounts in the Proc Registry object reset to zero each time your JavaScript\r\napplication reloads (ie, you refresh the web page hosting it).  To build coverage statistics over time, you should \r\naccumulate ProcScript runCounts into persistent storage of some kind.\r\n\r\nIf a ProcRecord has a runCount of zero, then ProcScript has not run it since the JavaScript application loaded.  If a \r\nProcRecord has a non-zero runCount, however, it could have one or more BlockRecords with a zero runCount.   You should\r\nremember this when analyzing the statistics to determine your true code coverage.\r\n\r\nFinally, bear in mind that these code coverage statistics are only valid for the parts of your JavaScript application \r\nthat are coded as ProcScript Procs.  They cannot tell you anything about your coverage of non-ProcScript JavaScript.\r\n\r\n\r\n\r\nThe ProcScript API\r\n--------------------------------\r\n\r\nHere is a quick summary of the ProcScript API:\r\n\r\nPS API\r\n--------\r\n`PS` is the object that ProcScript makes available as a JavaScript global.  It provdes access\r\nto all ProcScript functionality as defined below.\r\n\r\n\r\nThese functions define, undefine or get a Proc in the ProcScript registry. \r\n\r\n\tPS.defineProc(configObject)\r\n\tPS.undefineProc(procName)\r\n\tPS.getProc(procName)\r\n    \r\nAdapter Procs call these functions to tell ProcScript whether they succeeded or failed.\r\n\r\n\tPS.procSucceeded(adapterProcInstance)\r\n\tPS.procFailed(adapterProcInstance, errorMessage)\r\n\t\t\r\nThese are the block function return values supported by ProcScript.\r\n\r\n    PS.NEXT\r\n\tPS.RETURN\r\n    PS.CONTINUE\r\n    PS.BREAK\r\n    PS.WAIT_FOR_CALLBACK\r\n\r\nThese functions add or remove ProcScript listeners.\r\n\r\n    PS.addListener(eventType, callback)\r\n    PS.removeListener(eventType, callback)\r\n\r\nThis function returns a string dump of all active ProcScript threads.\r\n\r\n    PS.threadsToString()\r\n\t\r\nThese functions provide access to ProcScript's code coverage statistics.\r\n\r\n    PS.cloneProcRegistry()\r\n    PS.codeCoverageToString()\r\n\r\nWorking with Promises \r\n------------------------------\r\n\r\n`PS.promiseToRun` takes a deferred, a Proc instance and (optionally) runParams, and returns a promise.\r\n\r\n\tPS.promiseToRun(deferred, proc, runParams)\r\n\r\n`PS.promiseToRun` runs the specified Proc instance and resolves or rejects the deferred when the Proc finishes.  If the Proc  \r\nsucceeds, it resolves the deferred with its parameter object.  If it fails, it rejects the deferred with its failure message.\r\n\r\n\r\nProc Runners \r\n------------------------------\r\n\r\nProcRunners are Adapter Procs that run multiple Proc Instances in various ways.  `PS.ProcList` is \r\na helper class for passing Proc Instances to a ProcRunner.\r\n\r\n\tPS.ProcList(arr)\r\n\tPS.ProcList.getArray()\r\n\r\nThe constructor function takes an array of Proc Instances.  It type-checks the array and ensures it is not empty.\r\n`getArray` returns the type-checked array of Proc Instances.\r\n\r\nProcScript pre-defines four ProcRunners for your convenience.  Set a timeout for a ProcRunner by calling \r\nPS.Proc.setTimeout() before running it.  Abort a running ProcRunner by calling PS.Proc.abort() on it.\r\n \r\nHere are the names and signatures of the four pre-defined ProcRunners:\r\n\r\nPS.SequenceProcRunner\r\n------------------------------\r\n\r\n    fnGetSignature: function () {\r\n        return {\r\n            procList: [PS.ProcList]\r\n        };\r\n    }\r\n\r\nPS.SequenceProcRunner runs the specified list of Procs in sequence. \r\nIf any Proc fails, PS.SequenceProcRunner fails.  \r\nOtherwise, PS.SequenceProcRunner succeeds.\r\n\t\r\nPS.FallbackProcRunner\r\n------------------------------\r\n\t\r\n    fnGetSignature: function () {\r\n        return {\r\n            procList: [PS.ProcList],\r\n            fallbackIndex: [\"number\", \"out\"]\r\n        };\r\n    }\r\n\r\nPS.FallbackProcRunner runs the specified list of Procs in sequence.  \r\nIf all the Procs fail, PS.FallbackProcRunner fails.  \r\nOtherwise, PS.FallbackProcRunner returns the index of the first successful Proc in 'fallbackIndex'.\r\n\r\nPS.RaceProcRunner\r\n------------------------------\r\n\r\n    fnGetSignature: function () {\r\n        return {\r\n            procList: [PS.ProcList],\r\n            winnerIndex: [\"number\", \"out\"]\r\n        };\r\n    }\r\n\r\nPS.RaceProcRunner starts all of the Procs in the specified list running simultaneously.  \r\nIf all the Procs fail, PS.RaceProcRunner fails.  \r\nOtherwise, PS.RaceProcRunner returns the index of the first successful Proc in 'fallbackIndex'.\r\n  \r\n\r\nPS.ParallelProcRunner\r\n------------------------------\r\n\r\n    fnGetSignature: function () {\r\n        return {\r\n            procList: [PS.ProcList]\r\n        };\r\n    }\r\n\t\r\nPS.ParallelProcRunner starts all of the Procs in the specified list running simultaneously.  \r\nIf any of the Procs fail, PS.ParallelProcRunner fails.\r\nOtherwise, PS.ParallelProcRunner succeeds.\r\n\r\n\t\r\nPS.Proc API\r\n-------------\r\n\r\n`PS.Proc` is the prototype (base class) for all Proc definitions.  All Proc Instances are \r\ninstances of `PS.Proc` and can access these functions:\r\n\r\n\trun ( [ runParams ] )\r\n\r\n`run` returns the thread Id of the running Proc Instance.\r\nYou can optionally pass `run` an object literal called `runParams`.  runParams can contain the following properties:\r\n\r\n\trunParams.timeout \r\n\trunParams.fnStatusChanged\r\n\t\r\nIf `runParams.timeout` is defined, ProcScript calls `setTimeout` on the Proc Instance with the specified value.\r\nIf `runParams.fnStatusChanged` is defined, ProcScript calls `addStatusChangedListener` on the Proc Instance with the specified value.\r\n\r\n\t\t\r\n\tabort ( [reason] )\r\n\r\naborts the Proc Instance.  If `reason` is specified, ProcScript reports it as the reason why the Proc Instance was aborted.\r\n\r\n\tsetTimeout(ms)\r\n\r\nIf the Proc has not finished after 'ms' milliseconds, it aborts itself with a reason of \"timeout\".  If 'ms' is zero, the Proc never times out.\r\n\r\n\tgetTimeout()\r\n\r\nReturns the millisecond timeout setting for the Proc.\r\n\r\n\tgetTimeoutReason()\r\n\r\nReturns the reason that the Proc timed out.  If the Proc has not timed out, returns undefined.\r\n\t\r\n\tsetInstanceName(name)\r\n\r\nSets the name associated with this Proc instance to the string `name`.\r\n\r\n\tgetInstanceName()\r\n\t\r\nReturns the name associated with this Proc instance or undefined.\r\n\r\n\tsucceeded()\r\n\r\ntrue if the Proc Instance succeeded.\r\n\t\r\n\tfailed()\r\n\r\ntrue if the Proc Instance failed or was aborted.\r\n\t\r\n\taborted()\r\n\r\ntrue if the Proc Instance was aborted.\r\n\t\r\n\tgetParameterObject()\r\n\r\ngets the Proc Instance's parameter object.  \r\nNOTE:  The \"in-out\" and \"out\" parameters are only guaranteed to be correct if the Proc Instance succeeded.\r\n\t\r\n\tgetFailure()\r\n\r\ngets the Proc Instance's failure reason.\r\n\t\r\n\tgetAbortReason()\r\n\r\nIf the Proc Instance was aborted, this returns the reason why.\r\n\t\r\n\tgetThreadId()\r\n\r\nreturns the unique Id of this Proc Instance's thread.\r\n\t\r\n\tgetCurrentForEachItem()\r\n\r\nIn `ForEach` loop Proc Instance, getCurrentForEachItem() gets the current array item being processed.\r\nReturns null if the Proc instance is not a `ForEach` loop Proc.\r\n\t\r\n\tgetCurrentLoopIterationIndex()\r\n\r\nIn loop Proc Instances, getCurrentLoopIterationIndex() returns the zero-based loop iteration count.\r\nReturns null if the Proc instance is not a loop Proc.\r\n\r\n\tcallStackToString()\r\n\r\ncallStackToString() returns a string dump of the ProcScript thread for this Proc Instance.\r\n\r\nYou can register for status change events from a Proc instance using this function:\r\n\r\n\taddStatusChangedListener(fnStatusChangedListener)\r\n\r\nwhere `fnProcStatusChanged` is a function like this:\r\n\r\n    fnStatusChangedListener = function (proc, status) { ... }\r\n\r\nwhere \r\n\r\n`proc`is the Proc whose status has changed and \r\n`status` is one of the following string values:  \r\n\r\n    PS.PROC_STATUS_RUNNING\r\n    PS.PROC_STATUS_FINISHED\r\n\r\n\r\nNOTE:  All Proc Instances have a private property named `_procState` that is reserved for use \r\nby ProcScript. \r\n\r\n\t_procState \r\n\r\nWhen defining Proc Locals on your Proc Instance, you may use any name other than `_procState`.\r\n\t\t\r\n\t\r\n\r\n\t\t\t\t","google":"kworam_procscript","note":"Don't delete this file! It's used internally to help with page regeneration."}